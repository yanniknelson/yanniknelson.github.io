<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/CSS/main.min.css" />
  <link rel="stylesheet" href="/CSS/blogPost.min.css" />
  <link rel="stylesheet" href="/CSS/ScrollBar.min.css" />
  <link rel="stylesheet" href="/Projects/TikTakToe/CSS/TikTakToe.min.css" />
  <link href="/favicon.ico" rel="icon" type="image/x-icon" />
  <title>Yannik Nelson - TikTakToe</title>
</head>

<body>
  <div id="scrollbar"></div>
  <div id="scrollThumb"></div>
  <header>
    <div class="header-container">
      <div class="content">
        <h1><a href="/index.html">Yannik Nelson</a></h1>
        <div class="links">
          <a href="https://www.linkedin.com/in/yannik-nelson" target="_blank">LinkedIn</a>
          <a href="https://github.com/yanniknelson" target="_blank">Github</a>
          <a href="mailto:yannikdanielnelson@gmail.com" target="_blank">Email</a>
          <a href="/Yannik-Nelson_CV.pdf" target="_blank">CV</a>
        </div>
      </div>
    </div>
    <hr />
  </header>
  <main>
    <h2>
      Tik-Tak-Toe
    </h2>
    <div class="content">
      <section class="paragraph left">
        <div class="blogText">
          <h3>MinMax</h3>
          <p class="with_header" , style="padding-bottom: 1%;">
            In order to build an AI that can play simple games such as Tik Tak Toe or Connect-4, we are able to use an algorithm known as minmax. 
            MinMax is acts as an ideal player, and assumes it's playing against another idea player, i.e. at every stage, both players make the best possible move, 
            however to do this, it needs a way of determining the quality of a move. <br/><br/>

            The algorithm works by creating a list of possible moves, choosing one and passing the resulting game state to the opposing play, which will do the same. 
            This repeats until the resulting game state is terminal, meaning either a play has won or no more moves can be made, at this point, the player will return 
            -1 if the computer lost, 1 if the computer won, or 0 if it was a draw. In effect the algorithm has just evaluated a path of moves through the game, returning 
            the value says "this path is worth this much", then undoes that move so that the next move can be evaluated. Once all the moves have been evaluated the current
            player will choose the best move for it (either the move with the maximum or minimum value) and return its value. This conintues until all the possible paths of 
            actions have been evaluated and finally the very top level of the algorithm choses the move with the highest value. <br/><br/>
            
            Note that this algorithm is only concerned about winning, not how quickly it will win, this means it may sometimes make descisions that won't result in an immediate 
            win, even if they are availbe, but if it does so, it will still always win. To value winning sooner rather than later, the depth of each action path should be used 
            to negatively impact the value of a game, this needs to be done carefully to ensure a loss at any point is always worse than a win (after any number of games). 
            My method (Not implemented in this version) does this dividing the scores by the depth, this causes the value of game sstates to approach 0 (a draw) as the number of 
            moves to reach them increases.
          </p>
        </div>
      </section>
      
      <div style="clear: both;"></div>
    </div>
    <h2>Try and beat MinMax at TikTakToe</h2>
    <div class="board" id="TikTakToe">

  </main>
  <script src="/JavaScript/Scroll.js"></script>
  <script src="/Projects/TikTakToe/JavaScript/TikTakToe.js"></script>
</body>

</html>